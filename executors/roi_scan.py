# executors/roi_scan.py
from __future__ import annotations

import os
import json
from dataclasses import dataclass
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict, List, Tuple


@dataclass
class ExecResult:
    ok: bool
    message: str
    written: List[str]


def _utc_now() -> str:
    return datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")


def _safe_mkdir(p: Path) -> None:
    p.mkdir(parents=True, exist_ok=True)


def _write_text(path: Path, content: str) -> None:
    _safe_mkdir(path.parent)
    path.write_text(content, encoding="utf-8")


def _append_text(path: Path, content: str) -> None:
    _safe_mkdir(path.parent)
    with path.open("a", encoding="utf-8") as f:
        f.write(content)


def _extract_deliverables(job: Dict[str, Any]) -> List[str]:
    dels = job.get("deliverables", [])
    if isinstance(dels, list):
        return [str(x) for x in dels]
    return []


def _roi_plan_markdown(job: Dict[str, Any]) -> str:
    ts = _utc_now()
    focus = job.get("focus", [])
    if not isinstance(focus, list):
        focus = []

    rules = job.get("rules", [])
    if not isinstance(rules, list):
        rules = []

    # Minimal, “always works”-plan: no external calls, no secrets needed.
    return (
        f"# ROI Plan\n\n"
        f"- Generated: **{ts}**\n"
        f"- Task: **ROI_SCAN**\n\n"
        f"## What this means\n"
        f"This is the first hard-proof deliverable from the executor layer.\n"
        f"It confirms the job lifecycle works end-to-end: outbox → runner → executor → committed results.\n\n"
        f"## Constraints (from job)\n"
        + ("\n".join([f"- {r}" for r in rules]) if rules else "- (none)\n")
        + "\n\n"
        f"## Focus (from job)\n"
        + ("\n".join([f"- {x}" for x in focus]) if focus else "- (none)\n")
        + "\n\n"
        f"## Next step\n"
        f"Implement real ROI scanning sources (news/finance/arb) inside this executor later.\n"
        f"For now: we only prove the executor layer is alive and writing deliverables deterministically.\n"
    )


def _autorun_log_entry(job: Dict[str, Any]) -> str:
    ts = _utc_now()
    job_task = job.get("task", "UNKNOWN")
    return f"[{ts}] EXECUTOR ROI_SCAN ran. task={job_task} status=SUCCESS\n"


def run(job: Dict[str, Any], repo_root: Path | None = None) -> ExecResult:
    """
    ROI_SCAN executor.
    Writes deliverables listed in job["deliverables"] (if any).
    Guarantees: never raises on normal IO errors; returns ok=False with message instead.
    """
    try:
        root = repo_root or Path(os.getenv("GITHUB_WORKSPACE", "."))

        deliverables = _extract_deliverables(job)

        written: List[str] = []

        # Default deliverables if job forgets them
        if not deliverables:
            deliverables = [
                "agent_results/ROI_PLAN.md",
                "ops/logs/AUTORUN_LOG.md",
            ]

        for rel in deliverables:
            rel = rel.strip().lstrip("/").replace("\\", "/")
            out_path = (root / rel).resolve()

            # Safety: don't allow writing outside repo root
            try:
                out_path.relative_to(root.resolve())
            except Exception:
                return ExecResult(False, f"Refusing to write outside repo: {rel}", written)

            if rel.endswith("agent_results/ROI_PLAN.md"):
                _write_text(out_path, _roi_plan_markdown(job))
                written.append(rel)
            elif rel.endswith("ops/logs/AUTORUN_LOG.md"):
                _append_text(out_path, _autorun_log_entry(job))
                written.append(rel)
            else:
                # If some future job asks for an unknown file, still produce something minimal.
                _write_text(out_path, f"Generated by ROI_SCAN executor at {_utc_now()}\n")
                written.append(rel)

        return ExecResult(True, "ROI_SCAN executed successfully", written)

    except Exception as e:
        return ExecResult(False, f"ROI_SCAN executor crashed: {e}", [])
